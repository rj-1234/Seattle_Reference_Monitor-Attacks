"""
This security layer inadequately handles A/B storage for files in RepyV2.
1. a valid file must start with the character 'S' and end with the character 'E', If any other characters(including lowercase,'s','e', etc) are the first or last characters, then the file is considered invalid

2. permit writeat() operation

3. two copies A/B files on disk, One is valid(used for reading), the other that is written to.
4. close the file if one is invalid, if both are valid, then close the old ont. 
Note:
    This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
    Also you need to give it an application to run.
    python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
    
    """
TYPE="type"
ARGS="args"
RETURN="return"
EXCP="exceptions"
TARGET="target"
FUNC="func"
OBJC="objc"

class ABFile():
  def __init__(self,filename,create):
    # globals
    mycontext['debug'] = False   
    # local (per object) reference to the underlying file
    self.Afn = filename+'.a'
    self.Bfn = filename+'.b'

    # make the files and add 'SE' to the readat file...
    if create:
      self.Afile = openfile(self.Afn,create)
      #open b version as well
      self.Bfile = openfile(self.Bfn,True)
      #if a version is empty, then write it
      if not self.Afile.readat(None,0) :
        self.Afile.writeat('SE',0)

  def writeat(self,data,offset):
    # Write the requested data to the B file using the sandbox's writeat call
    self.Bfile.writeat(data,offset)

  def readat(self,bytes,offset):
    # Read from the A file using the sandbox's readat...
    return self.Afile.readat(bytes,offset)
   
  def close(self):
    fileA = self.Afile.readat(None,0)
    fileB = self.Bfile.readat(None,0)
    #if b version is true, then delete the old version a, else delete b version
    if fileB.startswith("S") and fileB.endswith("E"):
      self.Afile.close()
      removefile(self.Afn)
      self.Afile = openfile(self.Afn, True)
      self.Afile.writeat(fileB, 0)
    self.Bfile.close()
    removefile(self.Bfn)
    self.Afile.close()



def ABopenfile(filename, create):
  return ABFile(filename,create)

# The code here sets up type checking and variable hiding for you.  You
# should not need to change anything below here.
sec_file_def = {"obj-type":ABFile,
                "name":"ABFile",
                "writeat":{"type":"func","args":(str,(int,long)),"exceptions":Exception,"return":(int,type(None)),"target":ABFile.writeat},
                "readat":{"type":"func","args":((int,long,type(None)),(int,long)),"exceptions":Exception,"return":str,"target":ABFile.readat},
                "close":{"type":"func","args":None,"exceptions":None,"return":(bool,type(None)),"target":ABFile.close}
           }

CHILD_CONTEXT_DEF["ABopenfile"] = {TYPE:OBJC,ARGS:(str,bool),EXCP:Exception,RETURN:sec_file_def,TARGET:ABopenfile}

# Execute the user code
secure_dispatch_module()